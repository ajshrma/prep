# Components & Props in React

## Table of Contents

1. [Understanding Components](#understanding-components)
2. [Types of Components](#types-of-components)
3. [Props in Detail](#props-in-detail)
4. [Component Composition](#component-composition)
5. [Component Patterns](#component-patterns)
6. [Best Practices](#best-practices)
7. [Common Pitfalls](#common-pitfalls)
8. [Practice Exercises](#practice-exercises)
9. [Interview Questions](#interview-questions)
10. [Additional Resources](#additional-resources)

## Understanding Components

Components are the fundamental building blocks of React applications. They encapsulate reusable UI elements along with their logic and state. Understanding components is crucial for building maintainable and scalable React applications.

### Core Concepts

1. Component Declaration

```jsx
// Functional Component
function Welcome({ name }) {
	return <h1>Hello, {name}!</h1>;
}

// Class Component
class Welcome extends React.Component {
	render() {
		return <h1>Hello, {this.props.name}!</h1>;
	}
}
```

2. Component Composition

```jsx
function App() {
	return (
		<div>
			<Welcome name="Alice" />
			<Welcome name="Bob" />
			<Welcome name="Charlie" />
		</div>
	);
}
```

3. Component State and Lifecycle

```jsx
function Counter() {
	// State management
	const [count, setCount] = useState(0);

	// Lifecycle management
	useEffect(() => {
		document.title = `Count: ${count}`;
	}, [count]);

	return (
		<div>
			<p>Count: {count}</p>
			<button onClick={() => setCount(count + 1)}>Increment</button>
		</div>
	);
}
```

## Types of Components

React supports several types of components, each serving different purposes and use cases. Understanding when to use each type is crucial for building efficient applications.

### 1. Functional Components

Functional components are the modern way to write React components. They are simple JavaScript functions that accept props and return React elements.

```jsx
// Simple functional component
function Greeting({ name, role }) {
	return (
		<div>
			<h1>Welcome, {name}!</h1>
			<p>Role: {role}</p>
		</div>
	);
}

// With hooks for state management
function UserProfile({ userId }) {
	const [user, setUser] = useState(null);
	const [loading, setLoading] = useState(true);

	useEffect(() => {
		async function fetchUser() {
			const data = await getUserData(userId);
			setUser(data);
			setLoading(false);
		}
		fetchUser();
	}, [userId]);

	if (loading) return <div>Loading...</div>;

	return (
		<div>
			<h2>{user.name}</h2>
			<p>{user.email}</p>
		</div>
	);
}
```

### 2. Class Components

While less common in modern React, class components are still important to understand, especially when maintaining legacy code.

```jsx
class Timer extends React.Component {
	constructor(props) {
		super(props);
		this.state = { seconds: 0 };
	}

	componentDidMount() {
		this.interval = setInterval(() => {
			this.setState((state) => ({
				seconds: state.seconds + 1,
			}));
		}, 1000);
	}

	componentWillUnmount() {
		clearInterval(this.interval);
	}

	render() {
		return <div>Seconds: {this.state.seconds}</div>;
	}
}
```

### 3. Pure Components

Pure components are optimized for performance by automatically implementing `shouldComponentUpdate` with a shallow prop and state comparison.

```jsx
// Class-based Pure Component
class PriceDisplay extends React.PureComponent {
	render() {
		const { price, currency } = this.props;
		return (
			<div>
				{currency}
				{price.toFixed(2)}
			</div>
		);
	}
}

// Functional Pure Component using React.memo
const MemoizedPriceDisplay = React.memo(
	function PriceDisplay({ price, currency }) {
		return (
			<div>
				{currency}
				{price.toFixed(2)}
			</div>
		);
	},
	(prevProps, nextProps) => {
		// Custom comparison function (optional)
		return (
			prevProps.price === nextProps.price &&
			prevProps.currency === nextProps.currency
		);
	}
);
```

### 4. Higher-Order Components (HOC)

HOCs are functions that take a component and return a new enhanced component. They're used for code reuse, adding additional functionality, and cross-cutting concerns.

```jsx
// HOC for adding loading state
function withLoading(WrappedComponent) {
	return function WithLoadingComponent({ isLoading, ...props }) {
		if (isLoading) {
			return <div>Loading...</div>;
		}

		return <WrappedComponent {...props} />;
	};
}

// Usage of HOC
const UserListWithLoading = withLoading(UserList);

// Component with authentication HOC
const withAuth = (WrappedComponent) => {
	return class extends React.Component {
		state = {
			isAuthenticated: false,
		};

		componentDidMount() {
			this.checkAuth();
		}

		checkAuth = () => {
			// Authentication logic
			const token = localStorage.getItem("token");
			this.setState({ isAuthenticated: !!token });
		};

		render() {
			if (!this.state.isAuthenticated) {
				return <Navigate to="/login" />;
			}

			return <WrappedComponent {...this.props} />;
		}
	};
};

// Usage
const ProtectedDashboard = withAuth(Dashboard);
```

## Props in Detail

Props (short for properties) are the mechanism for passing data from parent to child components in React. They are read-only and help make components reusable and dynamic.

### 1. Basic Props Usage

Props can be of any JavaScript type: strings, numbers, objects, arrays, functions, or even other React elements.

```jsx
// Component with various prop types
function UserCard({
	name, // string
	age, // number
	isOnline, // boolean
	hobbies, // array
	address, // object
	onProfileClick, // function
	avatar, // React element
}) {
	return (
		<div className="user-card">
			<div className="header">
				{avatar}
				<h2>{name}</h2>
				<span className={isOnline ? "online" : "offline"} />
			</div>

			<div className="details">
				<p>Age: {age}</p>
				<p>
					Location: {address.city}, {address.country}
				</p>

				<h3>Hobbies:</h3>
				<ul>
					{hobbies.map((hobby) => (
						<li key={hobby}>{hobby}</li>
					))}
				</ul>

				<button onClick={() => onProfileClick(name)}>View Profile</button>
			</div>
		</div>
	);
}

// Usage
function App() {
	const handleProfileClick = (userName) => {
		console.log(`Viewing ${userName}'s profile`);
	};

	return (
		<UserCard
			name="John Doe"
			age={28}
			isOnline={true}
			hobbies={["reading", "hiking", "photography"]}
			address={{ city: "New York", country: "USA" }}
			onProfileClick={handleProfileClick}
			avatar={<img src="/avatar.jpg" alt="John's avatar" />}
		/>
	);
}
```

### 2. Props Validation

Props validation helps catch bugs by validating the types and requirements of props a component receives.

```jsx
import PropTypes from "prop-types";

function ProductCard({
	id,
	name,
	price,
	description,
	categories,
	onAddToCart,
	discount,
}) {
	const finalPrice = discount ? price * (1 - discount) : price;

	return (
		<div className="product-card">
			<h2>{name}</h2>
			<p>{description}</p>
			<div className="categories">
				{categories.map((cat) => (
					<span key={cat} className="category-tag">
						{cat}
					</span>
				))}
			</div>
			<div className="price">
				{discount && (
					<span className="original-price">${price.toFixed(2)}</span>
				)}
				<span className="final-price">${finalPrice.toFixed(2)}</span>
			</div>
			<button onClick={() => onAddToCart(id)}>Add to Cart</button>
		</div>
	);
}

ProductCard.propTypes = {
	id: PropTypes.string.isRequired,
	name: PropTypes.string.isRequired,
	price: PropTypes.number.isRequired,
	description: PropTypes.string,
	categories: PropTypes.arrayOf(PropTypes.string),
	onAddToCart: PropTypes.func.isRequired,
	discount: PropTypes.number,
	metadata: PropTypes.shape({
		manufacturer: PropTypes.string,
		releaseDate: PropTypes.instanceOf(Date),
		ratings: PropTypes.arrayOf(
			PropTypes.shape({
				user: PropTypes.string,
				score: PropTypes.number,
			})
		),
	}),
};

ProductCard.defaultProps = {
	description: "No description available",
	categories: [],
	discount: 0,
};
```

### 3. Children Props

The children prop allows components to pass JSX elements as child content, enabling flexible component composition.

```jsx
function Panel({ title, children, theme = "light", collapsible = false }) {
	const [isCollapsed, setIsCollapsed] = useState(false);

	return (
		<div className={`panel panel-${theme}`}>
			<div className="panel-header">
				<h3>{title}</h3>
				{collapsible && (
					<button
						onClick={() => setIsCollapsed(!isCollapsed)}
						className="collapse-btn"
					>
						{isCollapsed ? "Expand" : "Collapse"}
					</button>
				)}
			</div>

			<div className={`panel-content ${isCollapsed ? "collapsed" : ""}`}>
				{children}
			</div>
		</div>
	);
}

// Usage with different content structures
function App() {
	return (
		<div>
			<Panel title="User Information" theme="dark">
				<UserProfile userId="123" />
			</Panel>

			<Panel title="Settings" collapsible>
				<form>
					<label>
						Theme:
						<select>
							<option>Light</option>
							<option>Dark</option>
						</select>
					</label>
					<button type="submit">Save</button>
				</form>
			</Panel>

			<Panel title="Recent Activity">
				<ActivityList />
				<Pagination />
			</Panel>
		</div>
	);
}
```

### 4. Render Props

Render props is a technique for sharing code between components using a prop whose value is a function that returns a React element.

```jsx
function DataFetcher({
	url,
	render,
	loadingComponent = <div>Loading...</div>,
	errorComponent = (error) => <div>Error: {error.message}</div>,
}) {
	const [data, setData] = useState(null);
	const [loading, setLoading] = useState(true);
	const [error, setError] = useState(null);

	useEffect(() => {
		const fetchData = async () => {
			try {
				setLoading(true);
				const response = await fetch(url);
				const json = await response.json();
				setData(json);
			} catch (err) {
				setError(err);
			} finally {
				setLoading(false);
			}
		};

		fetchData();
	}, [url]);

	if (loading) return loadingComponent;
	if (error) return errorComponent(error);
	return render(data);
}

// Usage
function UserList() {
	return (
		<DataFetcher
			url="/api/users"
			render={(users) => (
				<div className="user-list">
					{users.map((user) => (
						<UserCard key={user.id} user={user} />
					))}
				</div>
			)}
			loadingComponent={<CustomSpinner />}
			errorComponent={(error) => (
				<ErrorBoundary error={error}>
					<RetryButton />
				</ErrorBoundary>
			)}
		/>
	);
}
```

## Component Composition

Component composition is a fundamental concept in React that allows you to combine smaller, focused components to build complex user interfaces. It promotes code reuse and maintainability.

### 1. Basic Composition

Basic composition involves combining components to create more complex UIs while maintaining clear separation of concerns.

```jsx
// Reusable components
function Avatar({ user, size = "medium" }) {
	return (
		<img
			src={user.avatarUrl}
			alt={user.name}
			className={`avatar avatar-${size}`}
		/>
	);
}

function UserInfo({ user }) {
	return (
		<div className="user-info">
			<Avatar user={user} />
			<div className="user-info-details">
				<h2>{user.name}</h2>
				<p>{user.role}</p>
			</div>
		</div>
	);
}

function Comment({ author, content, date }) {
	return (
		<div className="comment">
			<UserInfo user={author} />
			<div className="comment-content">
				<p>{content}</p>
				<span className="date">{date.toLocaleDateString()}</span>
			</div>
		</div>
	);
}

// Usage
function CommentList({ comments }) {
	return (
		<div className="comment-list">
			{comments.map((comment) => (
				<Comment
					key={comment.id}
					author={comment.author}
					content={comment.content}
					date={comment.date}
				/>
			))}
		</div>
	);
}
```

### 2. Specialization

Specialization is when a more specific component renders a more generic one with some additional props or behavior.

```jsx
// Generic Modal component
function Modal({
	isOpen,
	onClose,
	title,
	children,
	size = "medium",
	showCloseButton = true,
}) {
	if (!isOpen) return null;

	return (
		<div className="modal-overlay" onClick={onClose}>
			<div
				className={`modal modal-${size}`}
				onClick={(e) => e.stopPropagation()}
			>
				<header className="modal-header">
					<h2>{title}</h2>
					{showCloseButton && (
						<button className="close-button" onClick={onClose}>
							√ó
						</button>
					)}
				</header>
				<div className="modal-content">{children}</div>
			</div>
		</div>
	);
}

// Specialized modal components
function ConfirmationModal({
	isOpen,
	onClose,
	title,
	message,
	onConfirm,
	confirmText = "Confirm",
	cancelText = "Cancel",
}) {
	return (
		<Modal isOpen={isOpen} onClose={onClose} title={title} size="small">
			<p>{message}</p>
			<div className="modal-actions">
				<button className="button-secondary" onClick={onClose}>
					{cancelText}
				</button>
				<button className="button-primary" onClick={onConfirm}>
					{confirmText}
				</button>
			</div>
		</Modal>
	);
}

function FormModal({ isOpen, onClose, title, onSubmit, children }) {
	return (
		<Modal isOpen={isOpen} onClose={onClose} title={title} size="large">
			<form onSubmit={onSubmit}>
				{children}
				<div className="modal-actions">
					<button type="button" className="button-secondary" onClick={onClose}>
						Cancel
					</button>
					<button type="submit" className="button-primary">
						Submit
					</button>
				</div>
			</form>
		</Modal>
	);
}
```

### 3. Containment

Containment allows components to accept and render arbitrary children, making them highly flexible and reusable.

```jsx
// Layout components using containment
function Layout({ header, sidebar, main, footer }) {
	return (
		<div className="layout">
			<header className="layout-header">{header}</header>
			<div className="layout-body">
				<aside className="layout-sidebar">{sidebar}</aside>
				<main className="layout-main">{main}</main>
			</div>
			<footer className="layout-footer">{footer}</footer>
		</div>
	);
}

// Usage with different content for different pages
function DashboardPage() {
	return (
		<Layout
			header={<DashboardHeader />}
			sidebar={<DashboardNavigation />}
			main={<DashboardContent />}
			footer={<DashboardFooter />}
		/>
	);
}

function ProfilePage() {
	return (
		<Layout
			header={<ProfileHeader />}
			sidebar={<ProfileMenu />}
			main={<ProfileContent />}
			footer={<CommonFooter />}
		/>
	);
}

// Advanced containment with multiple slots
function TabPanel({ tabs, activeTab, onTabChange, renderTabContent }) {
	return (
		<div className="tab-panel">
			<div className="tab-list">
				{tabs.map((tab) => (
					<button
						key={tab.id}
						className={`tab ${activeTab === tab.id ? "active" : ""}`}
						onClick={() => onTabChange(tab.id)}
					>
						{tab.icon && <span className="tab-icon">{tab.icon}</span>}
						<span className="tab-label">{tab.label}</span>
					</button>
				))}
			</div>
			<div className="tab-content">{renderTabContent(activeTab)}</div>
		</div>
	);
}
```

## Component Patterns

React component patterns are proven solutions to common design challenges in React applications. Understanding these patterns helps you write more maintainable and reusable code.

### 1. Container/Presentational Pattern

This pattern separates data fetching and state management (container) from data display and styling (presentational).

```jsx
// Presentational Component
function UserList({ users, onUserSelect }) {
	return (
		<div className="user-list">
			{users.map((user) => (
				<div
					key={user.id}
					className="user-item"
					onClick={() => onUserSelect(user)}
				>
					<img src={user.avatar} alt={user.name} />
					<div className="user-info">
						<h3>{user.name}</h3>
						<p>{user.email}</p>
					</div>
				</div>
			))}
		</div>
	);
}

// Container Component
function UserListContainer() {
	const [users, setUsers] = useState([]);
	const [loading, setLoading] = useState(true);
	const [error, setError] = useState(null);

	useEffect(() => {
		async function fetchUsers() {
			try {
				setLoading(true);
				const response = await fetch("/api/users");
				const data = await response.json();
				setUsers(data);
			} catch (err) {
				setError(err.message);
			} finally {
				setLoading(false);
			}
		}

		fetchUsers();
	}, []);

	const handleUserSelect = (user) => {
		// Handle user selection logic
		console.log("Selected user:", user);
	};

	if (loading) return <LoadingSpinner />;
	if (error) return <ErrorMessage message={error} />;

	return <UserList users={users} onUserSelect={handleUserSelect} />;
}
```

### 2. Compound Components Pattern

This pattern creates a set of components that work together to form a cohesive unit while maintaining individual flexibility.

```jsx
// Create a context for sharing state
const AccordionContext = React.createContext();

// Main component
function Accordion({ children, defaultExpanded = false }) {
	const [expandedIndex, setExpandedIndex] = useState(defaultExpanded ? 0 : -1);

	return (
		<AccordionContext.Provider value={{ expandedIndex, setExpandedIndex }}>
			<div className="accordion">
				{React.Children.map(children, (child, index) => {
					return React.cloneElement(child, { index });
				})}
			</div>
		</AccordionContext.Provider>
	);
}

// Sub-components
Accordion.Item = function AccordionItem({ children, index }) {
	const { expandedIndex } = useContext(AccordionContext);
	const isExpanded = index === expandedIndex;

	return (
		<div className={`accordion-item ${isExpanded ? "expanded" : ""}`}>
			{React.Children.map(children, (child) => {
				return React.cloneElement(child, { isExpanded, index });
			})}
		</div>
	);
};

Accordion.Header = function AccordionHeader({ children, isExpanded, index }) {
	const { setExpandedIndex } = useContext(AccordionContext);

	return (
		<button
			className="accordion-header"
			onClick={() => setExpandedIndex(isExpanded ? -1 : index)}
		>
			{children}
			<span className={`arrow ${isExpanded ? "expanded" : ""}`}>‚ñº</span>
		</button>
	);
};

Accordion.Panel = function AccordionPanel({ children, isExpanded }) {
	return (
		<div className={`accordion-panel ${isExpanded ? "expanded" : ""}`}>
			{children}
		</div>
	);
};

// Usage
function FAQ() {
	return (
		<Accordion>
			<Accordion.Item>
				<Accordion.Header>What is React?</Accordion.Header>
				<Accordion.Panel>
					React is a JavaScript library for building user interfaces.
				</Accordion.Panel>
			</Accordion.Item>
			<Accordion.Item>
				<Accordion.Header>Why use React?</Accordion.Header>
				<Accordion.Panel>
					React makes it easy to create interactive UIs...
				</Accordion.Panel>
			</Accordion.Item>
		</Accordion>
	);
}
```

### 3. Render Props Pattern

This pattern uses a prop whose value is a function to share code between components.

```jsx
// Generic list component with render prop
function List({
	items,
	renderItem,
	renderEmpty = () => <p>No items to display</p>,
	keyExtractor = (item) => item.id,
}) {
	if (!items.length) {
		return renderEmpty();
	}

	return (
		<ul className="list">
			{items.map((item) => (
				<li key={keyExtractor(item)}>{renderItem(item)}</li>
			))}
		</ul>
	);
}

// Different implementations using the same List component
function UserDirectory({ users }) {
	return (
		<List
			items={users}
			renderItem={(user) => (
				<div className="user-card">
					<img src={user.avatar} alt={user.name} />
					<h3>{user.name}</h3>
					<p>{user.role}</p>
				</div>
			)}
			renderEmpty={() => (
				<div className="empty-state">
					<h3>No users found</h3>
					<p>Try adjusting your search criteria</p>
				</div>
			)}
		/>
	);
}

function TodoList({ todos, onToggle }) {
	return (
		<List
			items={todos}
			renderItem={(todo) => (
				<div className="todo-item">
					<input
						type="checkbox"
						checked={todo.completed}
						onChange={() => onToggle(todo.id)}
					/>
					<span
						style={{
							textDecoration: todo.completed ? "line-through" : "none",
						}}
					>
						{todo.text}
					</span>
				</div>
			)}
			renderEmpty={() => <p>All tasks completed! üéâ</p>}
		/>
	);
}
```

## Best Practices

Following React best practices helps create maintainable, performant, and bug-free applications. Here are key practices for components and props.

### 1. Component Organization

Components should be organized in a way that maximizes reusability and maintainability.

```jsx
// Good - Single Responsibility Principle
function UserProfile({ user }) {
	return (
		<div className="user-profile">
			<UserAvatar user={user} />
			<UserInfo user={user} />
			<UserStats user={user} />
		</div>
	);
}

// Bad - Too many responsibilities
function UserProfileBad({ user }) {
	return (
		<div className="user-profile">
			<div className="avatar">
				<img src={user.avatar} alt={user.name} />
				<div className="status-indicator" />
				<div className="avatar-overlay" />
			</div>
			<div className="info">
				<h2>{user.name}</h2>
				<p>{user.bio}</p>
				<div className="contact">
					<a href={`mailto:${user.email}`}>{user.email}</a>
					<p>{user.phone}</p>
				</div>
			</div>
			<div className="stats">
				<div className="followers">{user.followers}</div>
				<div className="following">{user.following}</div>
				<div className="posts">{user.posts}</div>
			</div>
		</div>
	);
}
```

### 2. Props Handling

Props should be handled in a way that makes components flexible and maintainable.

```jsx
// Good - Destructuring with defaults
function Button({
	children,
	type = "button",
	variant = "primary",
	size = "medium",
	disabled = false,
	onClick,
	className,
	...rest
}) {
	return (
		<button
			type={type}
			className={`btn btn-${variant} btn-${size} ${className || ""}`}
			disabled={disabled}
			onClick={onClick}
			{...rest}
		>
			{children}
		</button>
	);
}

// Bad - No defaults, no prop spreading for accessibility
function ButtonBad(props) {
	return (
		<button className={`btn btn-${props.variant}`} onClick={props.onClick}>
			{props.children}
		</button>
	);
}

// Usage
function App() {
	return (
		<div>
			<Button
				variant="success"
				size="large"
				onClick={() => console.log("clicked")}
				aria-label="Submit form"
			>
				Submit
			</Button>
		</div>
	);
}
```

### 3. Performance Optimization

Implement performance optimizations when necessary, but avoid premature optimization.

```jsx
// Good - Memoization when needed
const ExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
	// Expensive computation
	const processedData = useMemo(() => {
		return data.map((item) => expensiveOperation(item));
	}, [data]);

	return (
		<div>
			{processedData.map((item) => (
				<div key={item.id}>{item.value}</div>
			))}
		</div>
	);
});

// Good - Callback memoization
function SearchForm({ onSearch }) {
	const [query, setQuery] = useState("");

	const handleSearch = useCallback(() => {
		onSearch(query);
	}, [query, onSearch]);

	return (
		<div>
			<input value={query} onChange={(e) => setQuery(e.target.value)} />
			<Button onClick={handleSearch}>Search</Button>
		</div>
	);
}
```

### 4. Error Handling

Implement proper error handling and provide meaningful feedback to users.

```jsx
// Good - Error Boundary Component
class ErrorBoundary extends React.Component {
	state = { hasError: false, error: null };

	static getDerivedStateFromError(error) {
		return { hasError: true, error };
	}

	render() {
		if (this.state.hasError) {
			return (
				this.props.fallback?.(this.state.error) || (
					<div className="error-boundary">
						<h2>Something went wrong</h2>
						<p>{this.state.error.message}</p>
					</div>
				)
			);
		}

		return this.props.children;
	}
}

// Good - Component with error handling
function DataFetcher({
	url,
	children,
	loadingFallback = <div>Loading...</div>,
	errorFallback = (error) => (
		<div className="error-message">
			Error: {error.message}
			<button onClick={() => window.location.reload()}>Retry</button>
		</div>
	),
}) {
	const [data, setData] = useState(null);
	const [loading, setLoading] = useState(true);
	const [error, setError] = useState(null);

	useEffect(() => {
		let mounted = true;

		async function fetchData() {
			try {
				setLoading(true);
				setError(null);
				const response = await fetch(url);
				if (!response.ok) {
					throw new Error(`HTTP error! status: ${response.status}`);
				}
				const result = await response.json();
				if (mounted) {
					setData(result);
				}
			} catch (err) {
				if (mounted) {
					setError(err);
				}
			} finally {
				if (mounted) {
					setLoading(false);
				}
			}
		}

		fetchData();

		return () => {
			mounted = false;
		};
	}, [url]);

	if (loading) return loadingFallback;
	if (error) return errorFallback(error);
	return children(data);
}

// Usage
function UserList() {
	return (
		<ErrorBoundary>
			<DataFetcher url="/api/users">
				{(users) => (
					<div className="user-list">
						{users.map((user) => (
							<UserCard key={user.id} user={user} />
						))}
					</div>
				)}
			</DataFetcher>
		</ErrorBoundary>
	);
}
```

## Common Pitfalls

When working with React components and props, there are several common mistakes that developers should avoid. Understanding these pitfalls helps write more robust and maintainable code.

### 1. Mutating Props

Props should never be mutated as they are meant to be read-only. Mutating props can lead to unexpected behavior and bugs.

```jsx
// Bad - Mutating props directly
function UserProfile({ user }) {
	// ‚ùå Never modify props directly
	user.lastSeen = new Date();

	return (
		<div>
			<h2>{user.name}</h2>
			<p>Last seen: {user.lastSeen.toLocaleString()}</p>
		</div>
	);
}

// Good - Using state for modifications
function UserProfile({ user }) {
	const [lastSeen, setLastSeen] = useState(new Date());

	return (
		<div>
			<h2>{user.name}</h2>
			<p>Last seen: {lastSeen.toLocaleString()}</p>
		</div>
	);
}

// Good - Lifting state up
function UserProfile({ user, onUpdateLastSeen }) {
	useEffect(() => {
		onUpdateLastSeen(new Date());
	}, [onUpdateLastSeen]);

	return (
		<div>
			<h2>{user.name}</h2>
			<p>Last seen: {user.lastSeen.toLocaleString()}</p>
		</div>
	);
}
```

### 2. Prop Drilling

Passing props through multiple levels of components can make code harder to maintain. Use context or state management for deeply nested data.

```jsx
// Bad - Prop drilling through multiple levels
function App({ user }) {
	return (
		<div>
			<Header user={user} />
			<Main user={user} />
			<Footer user={user} />
		</div>
	);
}

function Main({ user }) {
	return (
		<div>
			<Sidebar user={user} />
			<Content user={user} />
		</div>
	);
}

function Content({ user }) {
	return (
		<div>
			<UserProfile user={user} />
		</div>
	);
}

// Good - Using Context
const UserContext = React.createContext();

function App({ user }) {
	return (
		<UserContext.Provider value={user}>
			<div>
				<Header />
				<Main />
				<Footer />
			</div>
		</UserContext.Provider>
	);
}

function Content() {
	const user = useContext(UserContext);
	return (
		<div>
			<UserProfile />
		</div>
	);
}

// Good - Component Composition
function App({ user }) {
	const header = <Header />;
	const content = <UserProfile user={user} />;
	const footer = <Footer />;

	return <Layout header={header} content={content} footer={footer} />;
}
```

### 3. Inconsistent Props Validation

Missing or inconsistent props validation can lead to runtime errors and make components harder to use correctly.

```jsx
// Bad - Inconsistent or missing prop types
function UserCard({ user }) {
	return (
		<div>
			<h2>{user.name}</h2>
			<p>{user.email}</p>
		</div>
	);
}

// Good - Comprehensive prop types
function UserCard({ user }) {
	return (
		<div>
			<h2>{user.name}</h2>
			<p>{user.email}</p>
		</div>
	);
}

UserCard.propTypes = {
	user: PropTypes.shape({
		id: PropTypes.string.isRequired,
		name: PropTypes.string.isRequired,
		email: PropTypes.string.isRequired,
		avatar: PropTypes.string,
		role: PropTypes.oneOf(["admin", "user", "guest"]),
		metadata: PropTypes.shape({
			lastLogin: PropTypes.instanceOf(Date),
			preferences: PropTypes.object,
		}),
	}).isRequired,
};

// Even Better - TypeScript with interfaces
interface User {
	id: string;
	name: string;
	email: string;
	avatar?: string;
	role: "admin" | "user" | "guest";
	metadata?: {
		lastLogin: Date,
		preferences: Record<string, unknown>,
	};
}

interface UserCardProps {
	user: User;
	onUserClick?: (userId: string) => void;
	className?: string;
}

function UserCard({ user, onUserClick, className }: UserCardProps) {
	return (
		<div className={className} onClick={() => onUserClick?.(user.id)}>
			<h2>{user.name}</h2>
			<p>{user.email}</p>
		</div>
	);
}
```

### 4. Overusing Props

Passing too many props to a component can make it inflexible and hard to maintain. Consider breaking down complex components.

```jsx
// Bad - Too many props
function UserForm({
	name,
	email,
	phone,
	address,
	city,
	country,
	zipCode,
	title,
	company,
	department,
	role,
	salary,
	startDate,
	manager,
	team,
	projects,
	onSubmit,
	onCancel,
	// ... more props
}) {
	return (/* ... */);
}

// Good - Breaking down into smaller components
function UserForm({ user, onSubmit, onCancel }) {
	return (
		<form onSubmit={onSubmit}>
			<PersonalInfoSection user={user} />
			<ContactDetailsSection user={user} />
			<EmploymentDetailsSection user={user} />
			<FormActions onCancel={onCancel} />
		</form>
	);
}

// Good - Using compound components
function UserForm({ children, onSubmit }) {
	return <form onSubmit={onSubmit}>{children}</form>;
}

UserForm.PersonalInfo = function PersonalInfo({ user }) {
	return (/* ... */);
};

UserForm.ContactDetails = function ContactDetails({ user }) {
	return (/* ... */);
};

UserForm.EmploymentDetails = function EmploymentDetails({ user }) {
	return (/* ... */);
};

// Usage
function App() {
	return (
		<UserForm onSubmit={handleSubmit}>
			<UserForm.PersonalInfo user={user} />
			<UserForm.ContactDetails user={user} />
			<UserForm.EmploymentDetails user={user} />
		</UserForm>
	);
}
```

## Practice Exercises

These exercises will help you practice and reinforce your understanding of React components and props. Each exercise focuses on different aspects and patterns.

### Exercise 1: Building a Component Library

Create a reusable component library with proper props handling and documentation.

```jsx
// 1. Create a Button component with variants
function Button({
	children,
	variant = "primary",
	size = "medium",
	disabled = false,
	loading = false,
	icon,
	onClick,
	...props
}) {
	const baseClasses = "btn";
	const variantClasses = `btn-${variant}`;
	const sizeClasses = `btn-${size}`;
	const stateClasses = `${disabled ? "disabled" : ""} ${
		loading ? "loading" : ""
	}`;

	return (
		<button
			className={`${baseClasses} ${variantClasses} ${sizeClasses} ${stateClasses}`}
			disabled={disabled || loading}
			onClick={loading ? undefined : onClick}
			{...props}
		>
			{loading && <Spinner size="small" />}
			{icon && <span className="btn-icon">{icon}</span>}
			<span className="btn-text">{children}</span>
		</button>
	);
}

// 2. Create a Card component with flexible content areas
function Card({
	title,
	subtitle,
	media,
	children,
	footer,
	className,
	elevation = 1,
	...props
}) {
	return (
		<div
			className={`card elevation-${elevation} ${className || ""}`}
			{...props}
		>
			{media && <div className="card-media">{media}</div>}
			<div className="card-content">
				{title && (
					<div className="card-header">
						<h2 className="card-title">{title}</h2>
						{subtitle && <p className="card-subtitle">{subtitle}</p>}
					</div>
				)}
				<div className="card-body">{children}</div>
				{footer && <div className="card-footer">{footer}</div>}
			</div>
		</div>
	);
}

// Usage example
function App() {
	return (
		<div className="app">
			<Card
				title="Welcome Back"
				subtitle="Continue where you left off"
				media={<img src="/hero-image.jpg" alt="Welcome" />}
				footer={
					<div className="card-actions">
						<Button variant="text">Skip</Button>
						<Button>Continue</Button>
					</div>
				}
			>
				<p>Your recent activities and recommendations...</p>
			</Card>
		</div>
	);
}
```

### Exercise 2: Form Component System

Create a form system with controlled components and proper validation.

```jsx
// 1. Create base form components
function FormField({
	label,
	error,
	touched,
	required,
	children,
	helpText,
	className,
}) {
	const id = useId();
	const showError = touched && error;

	return (
		<div
			className={`form-field ${showError ? "has-error" : ""} ${
				className || ""
			}`}
		>
			{label && (
				<label htmlFor={id} className="form-label">
					{label}
					{required && <span className="required-mark">*</span>}
				</label>
			)}
			{React.cloneElement(children, {
				id,
				"aria-describedby": showError ? `${id}-error` : undefined,
				"aria-required": required,
			})}
			{showError && (
				<div id={`${id}-error`} className="error-message">
					{error}
				</div>
			)}
			{helpText && <div className="help-text">{helpText}</div>}
		</div>
	);
}

// Usage example
function LoginForm() {
	const [values, setValues] = useState({
		email: "",
		password: "",
	});

	const handleSubmit = (e) => {
		e.preventDefault();
		// Handle form submission
	};

	return (
		<form onSubmit={handleSubmit}>
			<FormField label="Email" required helpText="Enter your registered email">
				<input
					type="email"
					value={values.email}
					onChange={(e) =>
						setValues((prev) => ({
							...prev,
							email: e.target.value,
						}))
					}
				/>
			</FormField>

			<FormField label="Password" required helpText="At least 8 characters">
				<input
					type="password"
					value={values.password}
					onChange={(e) =>
						setValues((prev) => ({
							...prev,
							password: e.target.value,
						}))
					}
				/>
			</FormField>

			<Button type="submit">Login</Button>
		</form>
	);
}
```

### Exercise 3: List Component with Filtering

Create a flexible list component that supports filtering and custom item rendering.

```jsx
function FilterableList({
	items,
	renderItem,
	filterPredicate,
	emptyMessage = "No items found",
	loading = false,
}) {
	const [searchTerm, setSearchTerm] = useState("");

	const filteredItems = useMemo(() => {
		if (!searchTerm) return items;
		return items.filter((item) => filterPredicate(item, searchTerm));
	}, [items, searchTerm, filterPredicate]);

	if (loading) {
		return <div className="list-loading">Loading...</div>;
	}

	return (
		<div className="filterable-list">
			<div className="list-header">
				<input
					type="search"
					placeholder="Search..."
					value={searchTerm}
					onChange={(e) => setSearchTerm(e.target.value)}
					className="search-input"
				/>
			</div>

			<div className="list-content">
				{filteredItems.length > 0 ? (
					<ul className="list">
						{filteredItems.map((item, index) => (
							<li key={item.id || index} className="list-item">
								{renderItem(item)}
							</li>
						))}
					</ul>
				) : (
					<div className="empty-state">{emptyMessage}</div>
				)}
			</div>
		</div>
	);
}

// Usage example
function UserList({ users }) {
	const filterUsers = (user, term) => {
		const searchTerm = term.toLowerCase();
		return (
			user.name.toLowerCase().includes(searchTerm) ||
			user.email.toLowerCase().includes(searchTerm)
		);
	};

	return (
		<FilterableList
			items={users}
			filterPredicate={filterUsers}
			renderItem={(user) => (
				<div className="user-item">
					<h2>{user.name}</h2>
					<p>{user.email}</p>
				</div>
			)}
		/>
	);
}
```

### Exercise 2: Build a User Profile Component

Create a component that displays user information with proper prop validation.

### Exercise 3: Implement a Higher-Order Component

Create an HOC that adds loading state to any component.

## Interview Questions

### Basic Level

1. **What are React components and what are their advantages?**

   - Components are reusable, self-contained pieces of UI that can include both markup and logic
   - Advantages:
     - Reusability: Write once, use anywhere
     - Separation of concerns: Each component handles a specific piece of UI
     - Maintainability: Easier to test and debug isolated components

   ```jsx
   // Example of a reusable component
   function Button({ label, onClick, variant = "primary" }) {
   	return (
   		<button className={`btn btn-${variant}`} onClick={onClick}>
   			{label}
   		</button>
   	);
   }
   ```

2. **What is the difference between functional and class components?**

   - Functional components:
     - Simple functions that take props and return JSX
     - Use hooks for state and lifecycle features
     - More concise and easier to test
   - Class components:
     - ES6 classes that extend React.Component
     - Have built-in lifecycle methods
     - Can have local state without hooks

   ```jsx
   // Functional Component
   function Welcome({ name }) {
   	return <h1>Hello, {name}</h1>;
   }

   // Class Component
   class Welcome extends React.Component {
   	render() {
   		return <h1>Hello, {this.props.name}</h1>;
   	}
   }
   ```

### Intermediate Level

1. **How do you handle prop validation in React?**

   - PropTypes for runtime type checking
   - TypeScript for static type checking
   - Default props for fallback values

   ```jsx
   import PropTypes from "prop-types";

   function UserProfile({ name, age, email, isAdmin }) {
   	return (
   		<div>
   			<h2>{name}</h2>
   			<p>Age: {age}</p>
   			<p>Email: {email}</p>
   			{isAdmin && <span>Administrator</span>}
   		</div>
   	);
   }

   UserProfile.propTypes = {
   	name: PropTypes.string.isRequired,
   	age: PropTypes.number,
   	email: PropTypes.string.isRequired,
   	isAdmin: PropTypes.bool,
   };

   UserProfile.defaultProps = {
   	age: 0,
   	isAdmin: false,
   };
   ```

2. **Explain the concept of component composition and when to use it.**

   - Building complex UIs by combining simpler components
   - Alternatives to inheritance
   - Flexible and reusable design

   ```jsx
   // Generic container component
   function Card({ header, children, footer }) {
   	return (
   		<div className="card">
   			{header && <div className="card-header">{header}</div>}
   			<div className="card-body">{children}</div>
   			{footer && <div className="card-footer">{footer}</div>}
   		</div>
   	);
   }

   // Usage with composition
   function UserCard({ user }) {
   	return (
   		<Card
   			header={<h2>{user.name}</h2>}
   			footer={<button>View Profile</button>}
   		>
   			<p>{user.bio}</p>
   			<UserStats stats={user.stats} />
   		</Card>
   	);
   }
   ```

### Advanced Level

1. **How do you optimize component performance using React.memo and when should you use it?**

   - Prevents unnecessary re-renders of functional components
   - Use when component renders often with same props
   - Custom comparison function for complex props

   ```jsx
   const ExpensiveComponent = React.memo(
   	function ExpensiveComponent({ data, onUpdate }) {
   		return (
   			<div>
   				{/* Complex rendering logic */}
   				{data.map((item) => (
   					<ExpensiveItem key={item.id} item={item} onUpdate={onUpdate} />
   				))}
   			</div>
   		);
   	},
   	(prevProps, nextProps) => {
   		// Custom comparison logic
   		return (
   			prevProps.data.length === nextProps.data.length &&
   			prevProps.onUpdate === nextProps.onUpdate
   		);
   	}
   );
   ```

2. **Explain Higher-Order Components (HOCs) and their use cases.**

   - Functions that take a component and return an enhanced component
   - Used for cross-cutting concerns like authentication, logging
   - Alternative to mixins

   ```jsx
   // HOC for authentication
   function withAuth(WrappedComponent) {
   	return function AuthenticatedComponent(props) {
   		const [isAuthenticated, setIsAuthenticated] = useState(false);
   		const [isLoading, setIsLoading] = useState(true);

   		useEffect(() => {
   			checkAuthStatus().then((status) => {
   				setIsAuthenticated(status);
   				setIsLoading(false);
   			});
   		}, []);

   		if (isLoading) {
   			return <div>Loading...</div>;
   		}

   		if (!isAuthenticated) {
   			return <Navigate to="/login" />;
   		}

   		return <WrappedComponent {...props} />;
   	};
   }

   // Usage
   const ProtectedDashboard = withAuth(Dashboard);
   ```

## Additional Resources

### Official Documentation

1. **React Components and Props**

   - [Components and Props Guide](https://reactjs.org/docs/components-and-props.html)
   - Comprehensive overview of component architecture
   - Best practices for props management

2. **Component Design Patterns**

   - [React Patterns](https://reactpatterns.com/)
   - Common composition techniques
   - Performance optimization strategies

3. **TypeScript Integration**
   - [React TypeScript Guidelines](https://github.com/typescript-cheatsheets/react)
   - Type-safe components and props
   - Generic components patterns

### Recommended Reading

1. **Component Architecture**

   ```jsx
   // Example: Composable Card Component
   function Card({ header, children, footer }) {
   	return (
   		<div className="card">
   			{header && <div className="card-header">{header}</div>}
   			<div className="card-body">{children}</div>
   			{footer && <div className="card-footer">{footer}</div>}
   		</div>
   	);
   }

   // Usage
   <Card header={<h2>Welcome</h2>} footer={<button>Learn More</button>}>
   	<p>Card content goes here</p>
   </Card>;
   ```

2. **Props Patterns**
   ```jsx
   // Example: Flexible Component API
   function Button({
   	children,
   	variant = "primary",
   	size = "medium",
   	onClick,
   	disabled,
   	...props
   }) {
   	return (
   		<button
   			className={`btn btn-${variant} btn-${size}`}
   			onClick={onClick}
   			disabled={disabled}
   			{...props}
   		>
   			{children}
   		</button>
   	);
   }
   ```

### Practice Projects

1. **Component Library**
   Build a collection of reusable components:

   - Buttons and form controls
   - Layout components
   - Data display components
   - Navigation elements

2. **Application Shell**
   Create a flexible application shell:
   - Header with navigation
   - Sidebar for filters/menu
   - Main content area
   - Footer with sections

### Learning Resources

1. **Interactive Tutorials**

   - React Dev Tools tutorial
   - Component debugging guide
   - Performance profiling walkthrough

2. **Community Resources**
   - React Discord community
   - Stack Overflow tagged questions
   - React GitHub discussions
